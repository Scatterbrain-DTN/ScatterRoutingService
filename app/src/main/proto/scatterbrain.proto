syntax = "proto3";
option java_package = "com.example.uscatterbrain";
option java_outer_classname = "ScatterProto";


message UUID {
    uint64 lower = 1;
    uint64 upper = 2;
}

// used to advertise the presence of a scatterbrain device
// and to request the exchange of identities and blockdata
message Advertise {
    enum Provides {
        BLUETOOTHCLASSIC = 0;
        BLE = 1;
        WIFIP2P = 2;
        ULTRASOUND = 4;
    }
    repeated Provides provides = 1;
}

// header + metadata for a file, message or data stream
message BlockData {
    bytes from_fingerprint = 1;
    bytes to_fingerprint = 2;
    string application = 3;
    uint32 sessionid = 4;
    bool todisk = 5;
    repeated bytes nexthashes = 6; //size of this is fragment count
    uint32 blocksize = 7;
    bytes sig = 8;
}

// body of file, message, or data stream.
message BlockSequence {
    uint32 seqnum = 1;
    oneof data {
        bytes data_contents = 2;
        bool data_native = 3;
    }
}

message Luid {
    oneof val {
        UUID val_uuid = 1;
        bytes val_hash = 2;
    }
}

message ElectLeader {
    message Body {
        bytes salt = 1;
        Advertise.Provides provides = 2;
        oneof tiebreaker {
            UUID tiebreaker_val = 3;
            bool tiebreaker_gone = 4;
        }
    }
    oneof val {
        Body val_body = 1;
        bytes val_hash = 2;
    }
}

message Ack {
    enum Status {
        OK = 0;
        ERR = 1;
    }
    Status status = 1;
    oneof message {
        bool message_null = 2;
        string message_val = 3;
    }
}


// used to request switching to a different physical transport
message Upgrade {
    Advertise.Provides provides = 1;
    uint32 sessionid = 2;
    map<string, string> metadata = 3;
}


// a user identity with name and one or more keys
message Identity {
    string givenname = 1;
    map<string, bytes> keys = 2;
    bytes sig = 3;
}

// arbitrary metadata about the network
// used for building more complex routing algorithms someday
message RoutingMetadata {
    message RoutingPoint {
        UUID uuid = 1;
        bytes data = 2;
    }
    map<string, RoutingPoint> keyval = 3;
}