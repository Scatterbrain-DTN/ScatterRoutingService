package net.ballmerlabs.uscatterbrain.network.wifidirect

import io.reactivex.Completable
import io.reactivex.Flowable
import io.reactivex.Single
import io.reactivex.subjects.CompletableSubject
import net.ballmerlabs.uscatterbrain.WifiGroupSubcomponent
import net.ballmerlabs.uscatterbrain.db.entities.DbMessage
import net.ballmerlabs.uscatterbrain.db.entities.HashlessScatterMessage
import java.io.File
import java.util.UUID
import net.ballmerlabs.uscatterbrain.network.proto.*
import java.util.concurrent.TimeUnit

/**
 * dagger2 interface for WifiDirectRadioModule
 */
interface WifiDirectRadioModule {
    /**
     * Returns the suggested wifi band that we should used, based on internal metrics
     * @return band from FakeWifiP2pConfig
     */
    fun getBand(): Int

    /**
     * connect to a wifi direct group, initializing the global group state if the connection is successful.
     * This connection will remain active for as long as possible until the remote peer moves out of range or
     * removeCurrentGroup is called
     *
     * @param name ssid of the group to connect to
     * @param passphrase group passphrase
     * @param timeout fail and return error after this many seconds
     * @param band what band to attempt to connect on. If failed, this function will retry on other bands
     *
     * @return single emitting WifiDirectInfo of current group
     */
    fun connectToGroup(
        name: String,
        passphrase: String,
        timeout: Int,
        band: Int
    ): Single<WifiDirectInfo>

    /**
     * Create a group using createGroup() if it is not present, then handle transactions from remote peers
     * This group will remain active until all peers move out of range or removeCurrentGroup is called
     *
     * @param band band from FakeWifP2pConfig to connect on
     * @param remoteLuid remote peer's luid
     * @param selfLuid this peer's luid. This will remain the same until the group is removed, even if our actual luid changes
     *
     * @return single returning WifiDirectBootstrapRequest to share with remote peer
     */
    fun bootstrapUke(band: Int, remoteLuid: UUID, selfLuid: UUID): Single<WifiDirectBootstrapRequest>

    /**
     * Connects to a wifi direct group or reuses an existing connection, then executes a transaction
     * with all connected peers. The connection remains active until removed with removeCurrentGroup
     * or the remote peer moves out of range.
     *
     * @param req bootstrap request sent by the remote peer
     * @param remote luid of the remote peer
     *
     * @return completable completing when transaction is complete
     */
    fun bootstrapSeme(req: WifiDirectBootstrapRequest, remote: UUID)

    /**
     * Waits until no peers are connecte via wifi for the specified timeout, then removes the current
     * wifi direct connection.
     *
     * @param timeout time to wait before giving up
     * @param timeUnit time unit for timeout parameter
     *
     * @return completable completing when group is removed
     */
    fun safeShutdownGroup(timeout: Long, timeUnit: TimeUnit): Completable


    /**
     * Create a wifi direct group and start a server for handling requests from remore peers.
     * This group will remain active until all peers move out of range or removeCurrentGroup is called
     */
    fun createGroup(band: Int, remoteLuid: UUID, selfLuid: UUID): Single<WifiGroupSubcomponent>

    fun isCreatedGroup(): Boolean

    /**
     * Removes an existing wifi direct group if it exists
     * @return Completable
     */
    fun removeGroup(retries: Int = 10, delay: Int = 5): Completable

    /**
     * Ugly hack to determine if SoftAp or similar is hogging the wireless
     * adapter and blocking wifi direct
     *
     * @return Single emitting boolean, true if usable
     */
    fun wifiDirectIsUsable(): Single<Boolean>

    /**
     * Registers the wifi direct BroadcastReceiver
     */
    fun registerReceiver()

    /**
     * Unregisters the wifi direct BroadcastReceiver
     */
    fun unregisterReceiver()

    /**
     * Wrapper class combining BlockHeaderPacket, SequencePackets, and
     * a database entity
     *
     * Allows streaming messages from network directly into database/filestore
     *
     * @property headerPacket blockheader for this stream
     * @property sequencePacketsParam Flowable of sequence packets corresponding to the header packet
     * @property entity database entity for inserting this stream into the datastore, possibly autogenerated
     */
    class BlockDataStream(
        val headerPacket: BlockHeaderPacket,
        private val sequencePacketsParam: Flowable<BlockSequencePacket>,
        val entity: DbMessage?,
    ) {
        private val sequenceCompletable = CompletableSubject.create()
        val sequencePackets: Flowable<BlockSequencePacket> = sequencePacketsParam
            .doOnComplete { sequenceCompletable.onComplete() }
            .doOnError { e -> sequenceCompletable.onError(e) }

        constructor(
            headerPacket: BlockHeaderPacket,
            sequencePackets: Flowable<BlockSequencePacket>,
            filePath: File
        ) : this(
            entity = DbMessage.from(headerPacket, filePath),
            headerPacket = headerPacket,
            sequencePacketsParam = sequencePackets
        )

        fun await(): Completable {
            return sequenceCompletable
        }

        val toDisk: Boolean
            get() = headerPacket.isFile

        constructor(
            message: DbMessage,
            packetFlowable: Flowable<BlockSequencePacket>,
            todisk: Boolean = true
        ) : this(
            headerPacket = BlockHeaderPacket.newBuilder()
                .setToFingerprint(message.toFingerprint.firstOrNull())
                .setFromFingerprint(message.toFingerprint.firstOrNull())
                .setApplication(message.message.application)
                .setSig(message.message.sig)
                .setToDisk(todisk)
                .setSessionID(message.message.sessionid)
                .setMime(message.message.mimeType)
                .setExtension(message.message.extension)
                .setHashes(HashlessScatterMessage.hashes2hashProto(message.file.messageHashes))
                .setEndOfStream(false)
                .build(),
            entity = message,
            sequencePacketsParam = packetFlowable
        )

        companion object {
            fun endOfStream(): BlockDataStream {
                return BlockDataStream(
                    BlockHeaderPacket.newBuilder().setEndOfStream(true).build(),
                    Flowable.empty(),
                    File("/")
                )
            }
        }
    }
}