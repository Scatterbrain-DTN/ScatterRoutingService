package net.ballmerlabs.uscatterbrain.network.proto

import com.google.protobuf.ByteString
import net.ballmerlabs.sbproto.SbPacket
import net.ballmerlabs.scatterproto.MAX_APPLICATION_NAME
import net.ballmerlabs.scatterproto.MAX_BLOCKS
import net.ballmerlabs.scatterproto.MAX_FILENAME
import net.ballmerlabs.scatterproto.MAX_FINGERPRINTS
import net.ballmerlabs.scatterproto.MAX_SIG
import net.ballmerlabs.scatterproto.ScatterSerializable
import net.ballmerlabs.scatterproto.Verifiable
import net.ballmerlabs.scatterproto.isValidFilename
import net.ballmerlabs.scatterproto.sanitizeFilename
import net.ballmerlabs.scatterproto.toProto
import net.ballmerlabs.scatterproto.toUuid
import proto.Scatterbrain.BlockData
import proto.Scatterbrain.MessageType
import java.util.Date
import java.util.UUID

/**
 * Wrapper class for protocol buffer blockdata message
 * @property hashList list of hashes of blocksequence packets
 * @property hashes array value of hashList
 * @property fromFingerprint fingerprint of identity that sent this message
 * @property sendDate timestamp of send
 * @property toFingerprint fingerprint of recipient identity, currently unused
 * @property signature ed25519 signature of this packet
 * @property application Scatterbrain application identifier this message belongs to
 * @property sessionID random identifier used for bootstrapping
 * @property isValidFilename true if filename meets requirements for inserting
 * @property isFile true if subsequent BlockSequencePackets should be written to disk
 * @property isEndOfStream true if this is the final message in a stream
 * @property mime mime type of stream data
 * @property userFilename filename to display
 * @property autogenFilename content-aware autogenerated filename, unique to this message
 */
@SbPacket(messageType = MessageType.BLOCK_HEADER)
data class BlockHeaderPacket(
    private val blockdata: BlockData,
) :
    ScatterSerializable<BlockData>(blockdata, MessageType.BLOCK_HEADER),
    Verifiable {
    /**
     * Gets hash list.
     *
     * @return the hash list
     */
    val hashList: List<ByteArray> = packet.nexthashesList.map { v -> v.toByteArray() }

    override val hashes = hashList.toTypedArray()


    /**
     * Gets from fingerprint.
     *
     * @return the from fingerprint
     */
    override val fromFingerprint: List<UUID> = packet.fromFingerprintList.map { f -> f.toUuid() }

    override val sendDate: Long = packet.sendDate

    /**
     * Gets to fingerprint.
     *
     * @return the to fingerprint
     */
    override val toFingerprint: List<UUID> = packet.toFingerprintList.map { f -> f.toUuid() }

    override val extension: String = sanitizeFilename(packet.extension)

    /**
     * Get signature byte [ ].
     *
     * @return the byte [ ]
     */
    override val signature: ByteArray = packet.sig.toByteArray()

    /**
     * Get application byte [ ].
     *
     * @return the byte [ ]
     */
    override val application: String = packet.application

    val isValidFilename: Boolean = isValidFilename(packet.filename)

    /**
     * Gets session id.
     *
     * @return the session id
     */
    val sessionID: Int = packet.sessionid

    override val isFile: Boolean = packet.todisk

    val isEndOfStream: Boolean = packet.endofstream

    override val mime: String = packet.mime

    override val userFilename: String = packet.filename

    val autogenFilename: String = UUID.randomUUID().toString()

    val isSigned: Boolean = packet.sig.size() != 0

    override fun validate(): Boolean {
        return fromFingerprint.size <= MAX_FINGERPRINTS && toFingerprint.size <= MAX_FINGERPRINTS && application.length <= MAX_APPLICATION_NAME && isValidFilename(
            extension
        ) && isValidFilename(packet.filename) && userFilename.length <= MAX_FILENAME && signature.size <= MAX_SIG && mime.length <= MAX_FILENAME && hashes.size <= MAX_BLOCKS
    }

    /**
     * Gets hash.
     *
     * @param seqnum the seqnum
     * @return the hash
     */
    fun getHash(seqnum: Int): ByteString {
        return packet.getNexthashes(seqnum)
    }

    /**
     * The type Builder.
     */
    data class Builder(
        private var toDisk: Boolean = false,
        private var application: String = "",
        private var sessionid: Int = -1,
        private var mToFingerprint: ArrayList<UUID> = arrayListOf(),
        private var mFromFingerprint: ArrayList<UUID> = arrayListOf(),
        private var extensionVal: String = "",
        private var hashlist: List<ByteString> = ArrayList(),
        private var sig: ByteArray? = null,
        private var filename: String = "",
        private var mime: String = "",
        private var endofstream: Boolean = false,
        private var sendDate: Date = Date(),
    ) {

        /**
         * Sets the fingerprint for the recipient.
         *
         * @param toFingerprint the to fingerprint
         * @return builder
         */
        fun setToFingerprint(toFingerprint: UUID?) = apply {
            if (toFingerprint != null) {
                mToFingerprint.add(toFingerprint)
            }
        }

        /**
         * Sets from fingerprint.
         *
         * @param fromFingerprint sets the fingerprint for the sender
         * @return builder
         */
        fun setFromFingerprint(fromFingerprint: UUID?) = apply {
            if (fromFingerprint != null) {
                mFromFingerprint.add(fromFingerprint)
            }
        }

        /**
         * Sets application.
         *
         * @param application bytes for UTF encoded scatterbrain application string
         * @return builder
         */
        fun setApplication(application: String) = apply {
            this.application = application
        }

        /**
         * Sets to disk.
         *
         * @param toDisk whether to write this file to disk or attempt to store it in the database
         * @return builder
         */
        fun setToDisk(toDisk: Boolean) = apply {
            this.toDisk = toDisk
        }

        /**
         * Sets session id.
         *
         * @param sessionID the session id (used for upgrading between protocols)
         * @return builder
         */
        fun setSessionID(sessionID: Int) = apply {
            sessionid = sessionID
        }

        /**
         * Sets hashes.
         *
         * @param hashes list of hashes of following blocksequence packets.
         * @return builder
         */
        fun setHashes(hashes: List<ByteString>) = apply {
            hashlist = hashes
        }

        /**
         * Sets the file extension
         * @param ext: string file extension
         * @return builder
         */
        fun setExtension(ext: String) = apply {
            this.extensionVal = sanitizeFilename(ext)
        }

        fun setSig(sig: ByteArray?) = apply {
            this.sig = sig
        }

        fun setMime(mime: String) = apply {
            this.mime = mime
        }

        fun setEndOfStream(value: Boolean) = apply {
            endofstream = value
        }

        fun setFilename(filename: String) = apply {
            this.filename = sanitizeFilename(filename)
        }

        fun setDate(date: Date) = apply {
            this.sendDate = date
        }

        /**
         * Build block header packet.
         *
         * @return the block header packet
         */
        fun build(): BlockHeaderPacket {
            val packet = BlockData.newBuilder().setApplication(application)
                .addAllFromFingerprint(mFromFingerprint.map { u -> u.toProto() })
                .addAllToFingerprint(mToFingerprint.map { u -> u.toProto() }).setTodisk(toDisk)
                .setExtension(extensionVal).addAllNexthashes(hashlist).setSessionid(sessionid)
                .setSendDate(sendDate.time).setMime(mime).setTtl(0).setEndofstream(endofstream)
                .setSig(ByteString.copyFrom(sig ?: byteArrayOf(0)))
                //     .setType(ScatterProto.MessageType.BLOCK_HEADER)
                .build()
            return BlockHeaderPacket(packet)
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) return true
            if (javaClass != other?.javaClass) return false

            other as Builder

            if (toDisk != other.toDisk) return false
            if (!application.contentEquals(other.application)) return false
            if (sessionid != other.sessionid) return false

            if (extensionVal != other.extensionVal) return false
            if (hashlist != other.hashlist) return false
            if (sig != null) {
                if (other.sig == null) return false
                if (!sig.contentEquals(other.sig)) return false
            } else if (other.sig != null) return false
            if (filename != other.filename) return false
            if (mime != other.mime) return false
            if (endofstream != other.endofstream) return false

            return true
        }

        override fun hashCode(): Int {
            var result = toDisk.hashCode()
            result = 31 * result + sessionid
            result = 31 * result + extensionVal.hashCode()
            result = 31 * result + hashlist.hashCode()
            result = 31 * result + (sig?.contentHashCode() ?: 0)
            result = 31 * result + filename.hashCode()
            result = 31 * result + mime.hashCode()
            result = 31 * result + endofstream.hashCode()
            return result
        }

        /**
         * Instantiates a new Builder.
         */
        init {
            sessionid = -1
            mime = "application/octet-stream"
        }
    }

    companion object {
        /**
         * New builder builder.
         *
         * @return the builder
         */
        @JvmStatic
        fun newBuilder(): Builder {
            return Builder()
        }
    }
}