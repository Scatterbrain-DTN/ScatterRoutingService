package net.ballmerlabs.uscatterbrain.network.bluetoothLE

import com.goterl.lazysodium.interfaces.GenericHash
import io.reactivex.Completable
import io.reactivex.Observable
import io.reactivex.Single
import io.reactivex.subjects.CompletableSubject
import net.ballmerlabs.uscatterbrain.ScatterProto.Role
import net.ballmerlabs.uscatterbrain.network.AdvertisePacket
import net.ballmerlabs.uscatterbrain.network.ElectLeaderPacket
import net.ballmerlabs.uscatterbrain.network.LibsodiumInterface
import net.ballmerlabs.uscatterbrain.network.UpgradePacket
import net.ballmerlabs.uscatterbrain.network.wifidirect.FakeWifiP2pConfig
import net.ballmerlabs.uscatterbrain.util.scatterLog
import java.math.BigInteger
import java.util.UUID
import java.util.concurrent.atomic.AtomicBoolean

/**
 * the voting stage handles the logic for the leader election algorithm which determines
 * in a semi-trustless fashion if a transport layer bootstrap is required and, if so,
 * to which transport to switch to.
 */

data class VotingResult(
    val provides: AdvertisePacket.Provides,
    val band: Int
)
class VotingStage(private val me: UUID, private val remoteLuid: UUID) : LeDeviceSession.Stage {
    private val LOG by scatterLog()
    var serverPackets = CompletableSubject.create()
    private val hashedPackets = ArrayList<ElectLeaderPacket>()
    private val unhashedPackets = ArrayList<ElectLeaderPacket>()
    private var tiebreaker = UUID.randomUUID()
    val stale = AtomicBoolean()
    fun getSelf(
        hashed: Boolean,
        provides: AdvertisePacket.Provides,
        force: Map<UUID, UpgradePacket>,
        sender: UUID,
        role: Role,
        band: Int
    ): ElectLeaderPacket {
        LOG.e("votingStage with forces ${force.size}")
        val builder: ElectLeaderPacket.Builder = ElectLeaderPacket.newBuilder(sender)
        if (hashed) {
            builder.enableHashing()
        }
        return builder
            .setProvides(provides)
            .setTiebreaker(tiebreaker)
            .setRole(role)
            .setBand(band)
            .setforceUke(force)
            .build()
    }

    override fun reset() {
        serverPackets = CompletableSubject.create()
        hashedPackets.clear()
        unhashedPackets.clear()
        tiebreaker = UUID.randomUUID()
    }

    /**
     * add a received electleaderpacket
     * @param packet
     */
    fun addPacket(packet: ElectLeaderPacket) {
        LOG.w("adding vote packet ${packet.isHashed}")
        if (packet.isHashed) {
            hashedPackets.add(packet)
        } else {
            unhashedPackets.add(packet)
        }
    }

    fun getBand(): Int {
        return unhashedPackets
            .fold(mutableMapOf<Int, Int>()) { acc, electLeaderPacket ->
                val v = acc[electLeaderPacket.band]?:FakeWifiP2pConfig.GROUP_OWNER_BAND_AUTO
                acc[electLeaderPacket.band] = v+1
                acc
            }
            .filter { v -> v.value != FakeWifiP2pConfig.GROUP_OWNER_BAND_AUTO }
            .maxBy { v -> v.value }
            .key
    }

    fun getForce(): Map<UUID, UpgradePacket> {
        return unhashedPackets
            .flatMap { p -> p.force.entries }
            .filter { p -> p.key != me && p.key != remoteLuid }
            .associate { (t, u) -> Pair(t, u) }
    }

    fun hashPackets(): BigInteger {
        var choice = BigInteger.ONE
        for (packet in unhashedPackets) {
            val newval = BigInteger(ElectLeaderPacket.uuidToBytes(packet.tieBreak))
            choice = choice.multiply(newval)
        }
        val hash = ByteArray(GenericHash.BYTES)
        LibsodiumInterface.sodium.crypto_generichash(
            hash,
            hash.size,
            choice.toByteArray(),
            choice.toByteArray().size.toLong(),
            null,
            0
        )
        return BigInteger(hash)
    }

    /**
     * Currently voting is done by committing to a UUID representing the device and then
     * choosing the uuid with the minimum distance to a collectively chosen random value
     *
     * Random numbers are generated by precommitting to hashed nonces and computing the product
     * of the nonces when all nonces are received. Since a salt is used "cheating" at this
     * should be very hard in the timeframe available to scatterbrain connection
     *
     * The reason we do this is to avoid devices cheating by always becoming UKE/SEME when
     * they want to (which could allow easier data collection / spying for some transports)
     * or by executing a downgrade attack by forcing devices into a less secure transport
     */
    fun selectUke(): BluetoothLEModule.ConnectionRole {
        stale.set(true)
        var compare = hashPackets()
        val ret = mutableMapOf<UUID, UpgradePacket>()
        var role: BluetoothLEModule.Role? = null
        val forces = getForce()
        LOG.e("voting forces ${forces.size}")
        val band = getBand()
        when (forces.size) {
            0 -> {
                val ukes = unhashedPackets.filter { r -> r.role == Role.UKE }
                if (ukes.size == 1 && ukes[0].from != me) {
                    role = BluetoothLEModule.Role.ROLE_SEME
                } else {
                    var r: UUID? = null
                    for (packet in unhashedPackets) {
                        val uuid = packet.from
                        val c = BigInteger(ElectLeaderPacket.uuidToBytes(uuid))
                        if (c.abs() < compare.abs()) {
                            r = uuid
                            compare = c
                        }
                    }
                    if (r != null) {
                        role = if (r == me) {
                            BluetoothLEModule.Role.ROLE_UKE
                        } else {
                            BluetoothLEModule.Role.ROLE_SEME
                        }
                    }
                }
            }

            else -> {
                ret.putAll(forces)
                role = BluetoothLEModule.Role.ROLE_SUPERSEME
            }
        }

        if (role == null) {
            throw MiracleException()
        }
        return BluetoothLEModule.ConnectionRole(
            luids = ret,
            role = role,
            band = band
        )
    }

    fun determineUpgrade(): Single<VotingResult> {
        return Single.fromCallable {
            val counts = mutableMapOf<Int, Int>()
            for (packet in unhashedPackets) {
                if (packet.provides == AdvertisePacket.Provides.BLE)
                    return@fromCallable VotingResult(provides = packet.provides, band = FakeWifiP2pConfig.GROUP_OWNER_BAND_AUTO)
                counts.compute(packet.band) { b, v -> (v?:0) + 1 }
            }
            VotingResult(provides = AdvertisePacket.Provides.WIFIP2P, band = counts.maxBy { v -> v.value }.key )
        }
    }

    /**
     * verify hashes of packets to prove precommittment
     * @return completable
     */
    fun verifyPackets(): Completable {
        return Completable.defer {
            if (hashedPackets.size != unhashedPackets.size) {
                Completable.error(IllegalStateException("size conflict hashed: ${hashedPackets.size} unhashed: ${unhashedPackets.size}"))
            } else Observable.zip(
                Observable.fromIterable(hashedPackets),
                Observable.fromIterable(unhashedPackets)
            ) { obj, packet -> obj.verifyHash(packet) }
                .flatMap { bool ->
                    if (!bool) {
                        Observable.error(java.lang.IllegalStateException("failed to verify hash"))
                    } else {
                        Observable.just(true)
                    }
                }
                .ignoreElements()
        }
    }

    /**
     * this is thrown in exceedingly rare cases if every device in the local mesh
     * has the same luid. This should only be thrown after the heat death of the universe
     */
    class MiracleException : RuntimeException()

}