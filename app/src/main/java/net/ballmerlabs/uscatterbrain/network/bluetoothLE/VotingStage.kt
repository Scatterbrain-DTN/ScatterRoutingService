package net.ballmerlabs.uscatterbrain.network.bluetoothLE

import com.goterl.lazysodium.interfaces.GenericHash
import io.reactivex.Completable
import io.reactivex.Observable
import io.reactivex.Single
import io.reactivex.subjects.CompletableSubject
import net.ballmerlabs.uscatterbrain.ScatterProto.Role
import net.ballmerlabs.uscatterbrain.network.AdvertisePacket
import net.ballmerlabs.uscatterbrain.network.ElectLeaderPacket
import net.ballmerlabs.uscatterbrain.network.LibsodiumInterface
import net.ballmerlabs.uscatterbrain.network.UpgradePacket
import net.ballmerlabs.uscatterbrain.util.scatterLog
import java.math.BigInteger
import java.util.UUID
import java.util.concurrent.atomic.AtomicBoolean

/**
 * the voting stage handles the logic for the leader election algorithm which determines
 * in a semi-trustless fashion if a transport layer bootstrap is required and, if so,
 * to which transport to switch to.
 */
class VotingStage(private val me: UUID, private val remoteLuid: UUID) : LeDeviceSession.Stage {
    private val LOG by scatterLog()
    val serverPackets = CompletableSubject.create()
    private val hashedPackets = ArrayList<ElectLeaderPacket>()
    private val unhashedPackets = ArrayList<ElectLeaderPacket>()
    private var tiebreaker = UUID.randomUUID()
    val stale = AtomicBoolean()
    fun getSelf(
        hashed: Boolean,
        provides: AdvertisePacket.Provides,
        force: Map<UUID, UpgradePacket>,
        sender: UUID,
        role: Role
    ): ElectLeaderPacket {
        LOG.e("votingStage with forces ${force.size}")
        val builder: ElectLeaderPacket.Builder = ElectLeaderPacket.newBuilder(sender)
        if (hashed) {
            builder.enableHashing()
        }
        return builder
            .setProvides(provides)
            .setTiebreaker(tiebreaker)
            .setRole(role)
            .setforceUke(force)
            .build()
    }

    override fun reset() {
        hashedPackets.clear()
        unhashedPackets.clear()
        tiebreaker = UUID.randomUUID()
    }

    /**
     * add a received electleaderpacket
     * @param packet
     */
    fun addPacket(packet: ElectLeaderPacket) {
        if (packet.isHashed) {
            hashedPackets.add(packet)
        } else {
            unhashedPackets.add(packet)
        }
    }

    /**
     * Currently voting is done by committing to a UUID representing the device and then
     * choosing the uuid with the minimum distance to a collectively chosen random value
     *
     * Random numbers are generated by precommitting to hashed nonces and computing the product
     * of the nonces when all nonces are received. Since a salt is used "cheating" at this
     * should be very hard in the timeframe available to scatterbrain connection
     *
     * The reason we do this is to avoid devices cheating by always becoming UKE/SEME when
     * they want to (which could allow easier data collection / spying for some transports)
     * or by executing a downgrade attack by forcing devices into a less secure transport
     */
    fun selectUke(): BluetoothLEModule.ConnectionRole {
        stale.set(true)
        var `val` = BigInteger.ONE
        for (packet in unhashedPackets) {
            val newval = BigInteger(ElectLeaderPacket.uuidToBytes(packet.tieBreak))
            `val` = `val`.multiply(newval)
        }
        val hash = ByteArray(GenericHash.BYTES)
        LibsodiumInterface.sodium.crypto_generichash(
            hash,
            hash.size,
            `val`.toByteArray(),
            `val`.toByteArray().size.toLong(),
            null,
            0
        )
        var compare = BigInteger(hash)
        var ret = mutableMapOf<UUID, UpgradePacket>()
        var role: BluetoothLEModule.Role? = null
        val forces =
            unhashedPackets
                .flatMap { p -> p.force.entries }
                .filter { p -> p.key != me && p.key != remoteLuid}
                .associate { (t, u) -> Pair(t, u) }
        LOG.e("voting forces ${forces.size}")
        when (forces.size) {
            0 -> {
                val ukes = unhashedPackets.filter { r -> r.role == Role.UKE}
                if (ukes.size == 1 && ukes[0].from != me) {
                    role = BluetoothLEModule.Role.ROLE_SEME
                } else {
                    var r: UUID? = null
                    for (packet in unhashedPackets) {
                        val uuid = packet.from
                        val c = BigInteger(ElectLeaderPacket.uuidToBytes(uuid))
                        if (c.abs() < compare.abs()) {
                            r = uuid
                            compare = c
                        }
                    }
                    if (r != null) {
                        role = if (r == me) {
                            BluetoothLEModule.Role.ROLE_UKE
                        } else {
                            BluetoothLEModule.Role.ROLE_SEME
                        }
                    }
                }
            }

            else -> {
                ret.putAll(forces)
                role = BluetoothLEModule.Role.ROLE_SUPERSEME
            }
        }

        if (role == null) {
            throw MiracleException()
        }
        return BluetoothLEModule.ConnectionRole(luids = ret, role = role)
    }

    private fun countVotes(): Single<AdvertisePacket.Provides> {
        return Observable.fromIterable(unhashedPackets)
            .map { p -> p.provides }
            .reduce(AdvertisePacket.Provides.WIFIP2P) { _, n ->
                if (n == AdvertisePacket.Provides.BLE) {
                    AdvertisePacket.Provides.BLE
                } else {
                    n
                }
            }
    }

    fun determineUpgrade(): Single<AdvertisePacket.Provides> {
        return countVotes()
    }

    /**
     * verify hashes of packets to prove precommittment
     * @return completable
     */
    fun verifyPackets(): Completable {
        return Completable.defer {
            if (hashedPackets.size != unhashedPackets.size) {
                Completable.error(IllegalStateException("size conflict hashed: ${hashedPackets.size} unhashed: ${unhashedPackets.size}"))
            } else Observable.zip(
                Observable.fromIterable(hashedPackets),
                Observable.fromIterable(unhashedPackets)
            ) { obj, packet -> obj.verifyHash(packet) }
                .flatMap { bool ->
                    if (!bool) {
                        Observable.error(java.lang.IllegalStateException("failed to verify hash"))
                    } else {
                        Observable.just(true)
                    }
                }
                .ignoreElements()
        }
    }

    /**
     * this is thrown in exceedingly rare cases if every device in the local mesh
     * has the same luid. This should only be thrown after the heat death of the universe
     */
    class MiracleException : RuntimeException()

}