package net.ballmerlabs.uscatterbrain.network.bluetoothLE

import com.goterl.lazysodium.interfaces.GenericHash
import io.reactivex.Completable
import io.reactivex.Observable
import io.reactivex.subjects.CompletableSubject
import net.ballmerlabs.scatterproto.Optional
import net.ballmerlabs.scatterproto.Provides
import net.ballmerlabs.uscatterbrain.network.proto.*
import net.ballmerlabs.uscatterbrain.network.LibsodiumInterface
import net.ballmerlabs.uscatterbrain.util.scatterLog
import java.math.BigInteger
import java.util.UUID

/**
 * the voting stage handles the logic for the leader election algorithm which determines
 * in a semi-trustless fashion if a transport layer bootstrap is required and, if so,
 * to which transport to switch to.
 */
class VotingStage(private val me: UUID) : LeDeviceSession.Stage {
    private val LOG by scatterLog()
    var serverPackets = CompletableSubject.create()
    private val hashedPackets = ArrayList<ElectLeaderPacket>()
    private val unhashedPackets = ArrayList<ElectLeaderPacket>()
    private var tiebreaker = UUID.randomUUID()
    var myUpgrade: Optional<UpgradePacket> = Optional.empty()


    fun getSelf(
        hashed: Boolean,
        provides: Provides,
        sender: UUID?,
        upgrade: Optional<UpgradePacket>,
    ): ElectLeaderPacket {
        val builder: ElectLeaderPacket.Builder = ElectLeaderPacket.newBuilder(sender)
        if (hashed) {
            builder.enableHashing()
        }
        if (upgrade.isPresent) {
            builder.setUpgrade(upgrade.item!!)
        }
        return builder
            .setProvides(provides)
            .setTiebreaker(tiebreaker)
            .build()
    }

    override fun reset() {
        serverPackets = CompletableSubject.create()
        hashedPackets.clear()
        unhashedPackets.clear()
        tiebreaker = UUID.randomUUID()
    }

    /**
     * add a received electleaderpacket
     * @param packet
     */
    fun addPacket(packet: ElectLeaderPacket) {
        LOG.w("adding vote packet ${packet.isHashed}")
        if (packet.isHashed) {
            hashedPackets.add(packet)
        } else {
            unhashedPackets.add(packet)
        }
    }

    private fun hashPackets(): BigInteger {
        var choice = BigInteger.ONE
        for (packet in unhashedPackets) {
            val newval = BigInteger(ElectLeaderPacket.uuidToBytes(packet.tieBreak))
            choice = choice.multiply(newval)
        }
        val hash = ByteArray(GenericHash.BYTES)
        LibsodiumInterface.sodium.crypto_generichash(
            hash,
            hash.size,
            choice.toByteArray(),
            choice.toByteArray().size.toLong(),
            null,
            0
        )
        return BigInteger(hash)
    }

    /**
     * Currently voting is done by committing to a UUID representing the device and then
     * choosing the uuid with the minimum distance to a collectively chosen random value
     *
     * Random numbers are generated by precommitting to hashed nonces and computing the product
     * of the nonces when all nonces are received. Since a salt is used "cheating" at this
     * should be very hard in the timeframe available to scatterbrain connection
     *
     * The reason we do this is to avoid devices cheating by always becoming UKE/SEME when
     * they want to (which could allow easier data collection / spying for some transports)
     * or by executing a downgrade attack by forcing devices into a less secure transport
     */
    fun selectUke(): BluetoothLEModule.ConnectionRole {
        var compare = hashPackets()
        var role: BluetoothLEModule.Role? = null
        val provides: Provides =
            if (unhashedPackets.all { p -> p.provides == Provides.WIFIP2P })
                Provides.WIFIP2P
            else
                Provides.BLE
        val upgrade = unhashedPackets
            .filter { p -> p.upgrade.isPresent }
        var r: UUID? = null
        for (packet in unhashedPackets) {
            val uuid = packet.from
            val c = BigInteger(ElectLeaderPacket.uuidToBytes(uuid))
            if (c.abs() < compare.abs()) {
                r = uuid
                compare = c
            }
        }

        if (r != null) {
            role = if (r == me) {
                BluetoothLEModule.Role.ROLE_UKE
            } else {
                BluetoothLEModule.Role.ROLE_SEME
            }
        }

        if (role == null) {
            throw MiracleException()
        }
        LOG.w("voting with upgrade size ${upgrade.size} me=$me")
        return when (upgrade.size) {
            1 -> {
                BluetoothLEModule.ConnectionRole(
                    role = if (upgrade[0].upgrade.item?.from == me)
                        BluetoothLEModule.Role.ROLE_SUPERUKE
                    else
                        BluetoothLEModule.Role.ROLE_SUPERSEME,
                    provides = provides,
                    drop = false,
                    upgrade = upgrade[0].upgrade
                )
            }

            0 -> {
                BluetoothLEModule.ConnectionRole(
                    role = role,
                    provides = provides,
                    drop = false,
                    upgrade = Optional.empty()
                )
            }

            else -> {
                for (u in upgrade) {
                    LOG.v("got compare upgrade ${u.upgrade}")
                }

                val isUke = upgrade.any { v -> v.upgrade.item?.from == me }
                val drop = upgrade.any { v -> v.upgrade.item?.from != me } && isUke
                val u = if (upgrade.zipWithNext { a, b ->
                        a.upgrade.item?.compare(b.upgrade.item!!)
                    }.all { v ->
                        val n = v == true
                        LOG.v("comparing upgrades: $n  me=$me")
                        n
                    }) {
                    Optional.of(upgrade[0])
                } else if (!isUke) {
                    Optional.of(upgrade[0])
                } else {
                    Optional.empty()
                }

                LOG.v("got compare upgrade ${u.item?.upgrade?.item?.from}")


                val nr = if (isUke && !drop)
                    BluetoothLEModule.Role.ROLE_SUPERUKE
                else
                    BluetoothLEModule.Role.ROLE_SUPERSEME

                BluetoothLEModule.ConnectionRole(
                    role = nr,
                    drop = drop,
                    provides = provides,
                    upgrade = u.item?.upgrade?: Optional.empty()
                )
            }
        }


    }

    /**
     * verify hashes of packets to prove precommittment
     * @return completable
     */
    fun verifyPackets(): Completable {
        return Completable.defer {
            if (hashedPackets.size != unhashedPackets.size) {
                Completable.error(IllegalStateException("size conflict hashed: ${hashedPackets.size} unhashed: ${unhashedPackets.size}"))
            } else Observable.zip(
                Observable.fromIterable(hashedPackets),
                Observable.fromIterable(unhashedPackets)
            ) { obj, packet -> obj.verifyHash(packet) }
                .flatMap { bool ->
                    if (!bool) {
                        Observable.error(java.lang.IllegalStateException("failed to verify hash"))
                    } else {
                        Observable.just(true)
                    }
                }
                .ignoreElements()
        }
    }

    /**
     * this is thrown in exceedingly rare cases if every device in the local mesh
     * has the same luid. This should only be thrown after the heat death of the universe
     */
    class MiracleException : RuntimeException()

}